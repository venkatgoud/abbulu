{"version":3,"sources":["webpack:///./node_modules/codemirror/addon/hint/anyword-hint.js"],"names":["CodeMirror","WORD","registerHelper","editor","options","word","range","cur","getCursor","curLine","getLine","line","end","ch","start","test","charAt","curWord","slice","list","seen","re","RegExp","source","dir","endLine","Math","min","max","firstLine","lastLine","m","text","exec","lastIndexOf","Object","prototype","hasOwnProperty","call","push","from","Pos","to","mod","__webpack_require__"],"mappings":"+EAUC,SAAAA,GACD,aAEA,IAAAC,EAAA,SAEAD,EAAAE,eAAA,0BAAAC,EAAAC,GAKA,IAJA,IAAAC,EAAAD,KAAAC,MAAAJ,EACAK,EAAAF,KAAAE,OAJA,IAKAC,EAAAJ,EAAAK,YAAAC,EAAAN,EAAAO,QAAAH,EAAAI,MACAC,EAAAL,EAAAM,GAAAC,EAAAF,EACAE,GAAAT,EAAAU,KAAAN,EAAAO,OAAAF,EAAA,OAAAA,EAKA,IAJA,IAAAG,EAAAH,GAAAF,GAAAH,EAAAS,MAAAJ,EAAAF,GAEAO,EAAAf,KAAAe,MAAA,GAAAC,EAAA,GACAC,EAAA,IAAAC,OAAAjB,EAAAkB,OAAA,KACAC,GAAA,EAAsBA,GAAA,EAAUA,GAAA,EAEhC,IADA,IAAAb,EAAAJ,EAAAI,KAAAc,EAAAC,KAAAC,IAAAD,KAAAE,IAAAjB,EAAAa,EAAAlB,EAAAH,EAAA0B,aAAA1B,EAAA2B,YAAAN,EACYb,GAAAc,EAAiBd,GAAAa,EAE7B,IADA,IAAAO,EAAAC,EAAA7B,EAAAO,QAAAC,GACAoB,EAAAV,EAAAY,KAAAD,IACArB,GAAAJ,EAAAI,MAAAoB,EAAA,KAAAd,GACAA,GAAA,GAAAc,EAAA,GAAAG,YAAAjB,EAAA,IAAAkB,OAAAC,UAAAC,eAAAC,KAAAlB,EAAAW,EAAA,MACAX,EAAAW,EAAA,OACAZ,EAAAoB,KAAAR,EAAA,KAKA,OAAYZ,OAAAqB,KAAAxC,EAAAyC,IAAAlC,EAAAI,KAAAG,GAAA4B,GAAA1C,EAAAyC,IAAAlC,EAAAI,KAAAC,MAjCZ+B,CAAQC,EAAQ","file":"12-9366a48b73254fa539e6.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var WORD = /[\\w$]+/, RANGE = 500;\n\n  CodeMirror.registerHelper(\"hint\", \"anyword\", function(editor, options) {\n    var word = options && options.word || WORD;\n    var range = options && options.range || RANGE;\n    var cur = editor.getCursor(), curLine = editor.getLine(cur.line);\n    var end = cur.ch, start = end;\n    while (start && word.test(curLine.charAt(start - 1))) --start;\n    var curWord = start != end && curLine.slice(start, end);\n\n    var list = options && options.list || [], seen = {};\n    var re = new RegExp(word.source, \"g\");\n    for (var dir = -1; dir <= 1; dir += 2) {\n      var line = cur.line, endLine = Math.min(Math.max(line + dir * range, editor.firstLine()), editor.lastLine()) + dir;\n      for (; line != endLine; line += dir) {\n        var text = editor.getLine(line), m;\n        while (m = re.exec(text)) {\n          if (line == cur.line && m[0] === curWord) continue;\n          if ((!curWord || m[0].lastIndexOf(curWord, 0) == 0) && !Object.prototype.hasOwnProperty.call(seen, m[0])) {\n            seen[m[0]] = true;\n            list.push(m[0]);\n          }\n        }\n      }\n    }\n    return {list: list, from: CodeMirror.Pos(cur.line, start), to: CodeMirror.Pos(cur.line, end)};\n  });\n});\n"],"sourceRoot":""}