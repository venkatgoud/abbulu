{"version":3,"sources":["webpack:///./node_modules/codemirror/addon/search/searchcursor.js"],"names":["CodeMirror","doFold","noFold","Pos","ensureFlags","regexp","flags","current","ignoreCase","global","multiline","regexpFlags","target","i","length","indexOf","charAt","RegExp","source","searchRegexpForward","doc","start","line","ch","last","lastLine","lastIndex","string","getLine","match","exec","from","index","to","lastMatchIn","cutOff","newMatch","adjustPos","orig","folded","pos","foldFunc","min","max","Math","mid","len","slice","SearchCursor","query","options","caseFold","this","atOccurrence","clipPos","matches","reverse","fold","lines","split","search","first","firstLine","found","lastIndexOf","top","topString","cutFrom","end","endString","chunk","curLine","before","inside","startLine","startCh","test","maybeMultiline","String","prototype","normalize","str","toLowerCase","findNext","find","findPrevious","result","cmpPos","replace","newText","origin","splitLines","replaceRange","defineExtension","defineDocExtension","ranges","cur","getSearchCursor","getCursor","push","anchor","head","setSelections","mod","__webpack_require__"],"mappings":"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","file":"14-21e4db5f6e4ae00103af.js","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n  var Pos = CodeMirror.Pos\n\n  function regexpFlags(regexp) {\n    var flags = regexp.flags\n    return flags != null ? flags : (regexp.ignoreCase ? \"i\" : \"\")\n      + (regexp.global ? \"g\" : \"\")\n      + (regexp.multiline ? \"m\" : \"\")\n  }\n\n  function ensureFlags(regexp, flags) {\n    var current = regexpFlags(regexp), target = current\n    for (var i = 0; i < flags.length; i++) if (target.indexOf(flags.charAt(i)) == -1)\n      target += flags.charAt(i)\n    return current == target ? regexp : new RegExp(regexp.source, target)\n  }\n\n  function maybeMultiline(regexp) {\n    return /\\\\s|\\\\n|\\n|\\\\W|\\\\D|\\[\\^/.test(regexp.source)\n  }\n\n  function searchRegexpForward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, last = doc.lastLine(); line <= last; line++, ch = 0) {\n      regexp.lastIndex = ch\n      var string = doc.getLine(line), match = regexp.exec(string)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpForwardMultiline(doc, regexp, start) {\n    if (!maybeMultiline(regexp)) return searchRegexpForward(doc, regexp, start)\n\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, last = doc.lastLine(); line <= last;) {\n      // This grows the search buffer in exponentially-sized chunks\n      // between matches, so that nearby matches are fast and don't\n      // require concatenating the whole document (in case we're\n      // searching for something that has tons of matches), but at the\n      // same time, the amount of retries is limited.\n      for (var i = 0; i < chunk; i++) {\n        if (line > last) break\n        var curLine = doc.getLine(line++)\n        string = string == null ? curLine : string + \"\\n\" + curLine\n      }\n      chunk = chunk * 2\n      regexp.lastIndex = start.ch\n      var match = regexp.exec(string)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = start.line + before.length - 1, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  function lastMatchIn(string, regexp) {\n    var cutOff = 0, match\n    for (;;) {\n      regexp.lastIndex = cutOff\n      var newMatch = regexp.exec(string)\n      if (!newMatch) return match\n      match = newMatch\n      cutOff = match.index + (match[0].length || 1)\n      if (cutOff == string.length) return match\n    }\n  }\n\n  function searchRegexpBackward(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"g\")\n    for (var line = start.line, ch = start.ch, first = doc.firstLine(); line >= first; line--, ch = -1) {\n      var string = doc.getLine(line)\n      if (ch > -1) string = string.slice(0, ch)\n      var match = lastMatchIn(string, regexp)\n      if (match)\n        return {from: Pos(line, match.index),\n                to: Pos(line, match.index + match[0].length),\n                match: match}\n    }\n  }\n\n  function searchRegexpBackwardMultiline(doc, regexp, start) {\n    regexp = ensureFlags(regexp, \"gm\")\n    var string, chunk = 1\n    for (var line = start.line, first = doc.firstLine(); line >= first;) {\n      for (var i = 0; i < chunk; i++) {\n        var curLine = doc.getLine(line--)\n        string = string == null ? curLine.slice(0, start.ch) : curLine + \"\\n\" + string\n      }\n      chunk *= 2\n\n      var match = lastMatchIn(string, regexp)\n      if (match) {\n        var before = string.slice(0, match.index).split(\"\\n\"), inside = match[0].split(\"\\n\")\n        var startLine = line + before.length, startCh = before[before.length - 1].length\n        return {from: Pos(startLine, startCh),\n                to: Pos(startLine + inside.length - 1,\n                        inside.length == 1 ? startCh + inside[0].length : inside[inside.length - 1].length),\n                match: match}\n      }\n    }\n  }\n\n  var doFold, noFold\n  if (String.prototype.normalize) {\n    doFold = function(str) { return str.normalize(\"NFD\").toLowerCase() }\n    noFold = function(str) { return str.normalize(\"NFD\") }\n  } else {\n    doFold = function(str) { return str.toLowerCase() }\n    noFold = function(str) { return str }\n  }\n\n  // Maps a position in a case-folded line back to a position in the original line\n  // (compensating for codepoints increasing in number during folding)\n  function adjustPos(orig, folded, pos, foldFunc) {\n    if (orig.length == folded.length) return pos\n    for (var min = 0, max = pos + Math.max(0, orig.length - folded.length);;) {\n      if (min == max) return min\n      var mid = (min + max) >> 1\n      var len = foldFunc(orig.slice(0, mid)).length\n      if (len == pos) return mid\n      else if (len > pos) max = mid\n      else min = mid + 1\n    }\n  }\n\n  function searchStringForward(doc, query, start, caseFold) {\n    // Empty string would match anything and never progress, so we\n    // define it to match nothing instead.\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, last = doc.lastLine() + 1 - lines.length; line <= last; line++, ch = 0) {\n      var orig = doc.getLine(line).slice(ch), string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.indexOf(lines[0])\n        if (found == -1) continue search\n        var start = adjustPos(orig, string, found, fold) + ch\n        return {from: Pos(line, adjustPos(orig, string, found, fold) + ch),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold) + ch)}\n      } else {\n        var cutFrom = string.length - lines[0].length\n        if (string.slice(cutFrom) != lines[0]) continue search\n        for (var i = 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(line + i)) != lines[i]) continue search\n        var end = doc.getLine(line + lines.length - 1), endString = fold(end), lastLine = lines[lines.length - 1]\n        if (endString.slice(0, lastLine.length) != lastLine) continue search\n        return {from: Pos(line, adjustPos(orig, string, cutFrom, fold) + ch),\n                to: Pos(line + lines.length - 1, adjustPos(end, endString, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function searchStringBackward(doc, query, start, caseFold) {\n    if (!query.length) return null\n    var fold = caseFold ? doFold : noFold\n    var lines = fold(query).split(/\\r|\\n\\r?/)\n\n    search: for (var line = start.line, ch = start.ch, first = doc.firstLine() - 1 + lines.length; line >= first; line--, ch = -1) {\n      var orig = doc.getLine(line)\n      if (ch > -1) orig = orig.slice(0, ch)\n      var string = fold(orig)\n      if (lines.length == 1) {\n        var found = string.lastIndexOf(lines[0])\n        if (found == -1) continue search\n        return {from: Pos(line, adjustPos(orig, string, found, fold)),\n                to: Pos(line, adjustPos(orig, string, found + lines[0].length, fold))}\n      } else {\n        var lastLine = lines[lines.length - 1]\n        if (string.slice(0, lastLine.length) != lastLine) continue search\n        for (var i = 1, start = line - lines.length + 1; i < lines.length - 1; i++)\n          if (fold(doc.getLine(start + i)) != lines[i]) continue search\n        var top = doc.getLine(line + 1 - lines.length), topString = fold(top)\n        if (topString.slice(topString.length - lines[0].length) != lines[0]) continue search\n        return {from: Pos(line + 1 - lines.length, adjustPos(top, topString, top.length - lines[0].length, fold)),\n                to: Pos(line, adjustPos(orig, string, lastLine.length, fold))}\n      }\n    }\n  }\n\n  function SearchCursor(doc, query, pos, options) {\n    this.atOccurrence = false\n    this.doc = doc\n    pos = pos ? doc.clipPos(pos) : Pos(0, 0)\n    this.pos = {from: pos, to: pos}\n\n    var caseFold\n    if (typeof options == \"object\") {\n      caseFold = options.caseFold\n    } else { // Backwards compat for when caseFold was the 4th argument\n      caseFold = options\n      options = null\n    }\n\n    if (typeof query == \"string\") {\n      if (caseFold == null) caseFold = false\n      this.matches = function(reverse, pos) {\n        return (reverse ? searchStringBackward : searchStringForward)(doc, query, pos, caseFold)\n      }\n    } else {\n      query = ensureFlags(query, \"gm\")\n      if (!options || options.multiline !== false)\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackwardMultiline : searchRegexpForwardMultiline)(doc, query, pos)\n        }\n      else\n        this.matches = function(reverse, pos) {\n          return (reverse ? searchRegexpBackward : searchRegexpForward)(doc, query, pos)\n        }\n    }\n  }\n\n  SearchCursor.prototype = {\n    findNext: function() {return this.find(false)},\n    findPrevious: function() {return this.find(true)},\n\n    find: function(reverse) {\n      var result = this.matches(reverse, this.doc.clipPos(reverse ? this.pos.from : this.pos.to))\n\n      // Implements weird auto-growing behavior on null-matches for\n      // backwards-compatiblity with the vim code (unfortunately)\n      while (result && CodeMirror.cmpPos(result.from, result.to) == 0) {\n        if (reverse) {\n          if (result.from.ch) result.from = Pos(result.from.line, result.from.ch - 1)\n          else if (result.from.line == this.doc.firstLine()) result = null\n          else result = this.matches(reverse, this.doc.clipPos(Pos(result.from.line - 1)))\n        } else {\n          if (result.to.ch < this.doc.getLine(result.to.line).length) result.to = Pos(result.to.line, result.to.ch + 1)\n          else if (result.to.line == this.doc.lastLine()) result = null\n          else result = this.matches(reverse, Pos(result.to.line + 1, 0))\n        }\n      }\n\n      if (result) {\n        this.pos = result\n        this.atOccurrence = true\n        return this.pos.match || true\n      } else {\n        var end = Pos(reverse ? this.doc.firstLine() : this.doc.lastLine() + 1, 0)\n        this.pos = {from: end, to: end}\n        return this.atOccurrence = false\n      }\n    },\n\n    from: function() {if (this.atOccurrence) return this.pos.from},\n    to: function() {if (this.atOccurrence) return this.pos.to},\n\n    replace: function(newText, origin) {\n      if (!this.atOccurrence) return\n      var lines = CodeMirror.splitLines(newText)\n      this.doc.replaceRange(lines, this.pos.from, this.pos.to, origin)\n      this.pos.to = Pos(this.pos.from.line + lines.length - 1,\n                        lines[lines.length - 1].length + (lines.length == 1 ? this.pos.from.ch : 0))\n    }\n  }\n\n  CodeMirror.defineExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this.doc, query, pos, caseFold)\n  })\n  CodeMirror.defineDocExtension(\"getSearchCursor\", function(query, pos, caseFold) {\n    return new SearchCursor(this, query, pos, caseFold)\n  })\n\n  CodeMirror.defineExtension(\"selectMatches\", function(query, caseFold) {\n    var ranges = []\n    var cur = this.getSearchCursor(query, this.getCursor(\"from\"), caseFold)\n    while (cur.findNext()) {\n      if (CodeMirror.cmpPos(cur.to(), this.getCursor(\"to\")) > 0) break\n      ranges.push({anchor: cur.from(), head: cur.to()})\n    }\n    if (ranges.length)\n      this.setSelections(ranges, 0)\n  })\n});\n"],"sourceRoot":""}